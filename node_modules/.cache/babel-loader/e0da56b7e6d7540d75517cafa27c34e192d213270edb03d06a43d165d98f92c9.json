{"ast":null,"code":"import _slicedToArray from \"/Users/hacktheplanet/Documents/GitHub/blog-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/Users/hacktheplanet/Documents/GitHub/blog-frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { useCallback, useMemo, useRef, useState } from \"react\";\nimport useSWR from \"swr\";\nimport useSWRInfinite from \"swr/infinite\";\nfunction getDifferentKeys(obj1, obj2) {\n  var keysSet = new Set(Object.keys(obj2));\n  var differentKeysObject = {};\n  for (var _i = 0, _Object$keys = Object.keys(obj1); _i < _Object$keys.length; _i++) {\n    var key1 = _Object$keys[_i];\n    if (!keysSet.has(key1)) {\n      differentKeysObject[key1] = obj1[key1];\n    }\n  }\n  return differentKeysObject;\n}\nvar useWithSafeValues = function useWithSafeValues(params, defaultValues) {\n  var _params$initialPage, _params$pageSize;\n  var shouldUseDefaults = typeof params === \"boolean\" && params;\n  var initialPageRef = useRef(shouldUseDefaults ? defaultValues.initialPage : (_params$initialPage = params === null || params === void 0 ? void 0 : params.initialPage) !== null && _params$initialPage !== void 0 ? _params$initialPage : defaultValues.initialPage);\n  var pageSizeRef = useRef(shouldUseDefaults ? defaultValues.pageSize : (_params$pageSize = params === null || params === void 0 ? void 0 : params.pageSize) !== null && _params$pageSize !== void 0 ? _params$pageSize : defaultValues.pageSize);\n  var newObj = {};\n  for (var _i2 = 0, _Object$keys2 = Object.keys(defaultValues); _i2 < _Object$keys2.length; _i2++) {\n    var _params$key;\n    var key = _Object$keys2[_i2];\n    newObj[key] = shouldUseDefaults ? defaultValues[key] : (_params$key = params === null || params === void 0 ? void 0 : params[key]) !== null && _params$key !== void 0 ? _params$key : defaultValues[key];\n  }\n  return _objectSpread(_objectSpread({}, newObj), {}, {\n    initialPage: initialPageRef.current,\n    pageSize: pageSizeRef.current\n  });\n};\nvar usePagesOrInfinite = function usePagesOrInfinite(params, fetcher, options, cacheKeys) {\n  var _params$initialPage2, _params$initialPage3, _params$pageSize2, _options$enabled, _options$infinite, _options$keepPrevious;\n  var _useState = useState((_params$initialPage2 = params.initialPage) !== null && _params$initialPage2 !== void 0 ? _params$initialPage2 : 1),\n    _useState2 = _slicedToArray(_useState, 2),\n    paginatedPage = _useState2[0],\n    setPaginatedPage = _useState2[1];\n  var initialPageRef = useRef((_params$initialPage3 = params.initialPage) !== null && _params$initialPage3 !== void 0 ? _params$initialPage3 : 1);\n  var pageSizeRef = useRef((_params$pageSize2 = params.pageSize) !== null && _params$pageSize2 !== void 0 ? _params$pageSize2 : 10);\n  var enabled = (_options$enabled = options.enabled) !== null && _options$enabled !== void 0 ? _options$enabled : true;\n  var triggerInfinite = (_options$infinite = options.infinite) !== null && _options$infinite !== void 0 ? _options$infinite : false;\n  var keepPreviousData = (_options$keepPrevious = options.keepPreviousData) !== null && _options$keepPrevious !== void 0 ? _options$keepPrevious : false;\n  var pagesCacheKey = _objectSpread(_objectSpread(_objectSpread({}, cacheKeys), params), {}, {\n    initialPage: paginatedPage,\n    pageSize: pageSizeRef.current\n  });\n  var _useSWR = useSWR(!triggerInfinite && !!fetcher && enabled ? pagesCacheKey : null, function (cacheKeyParams) {\n      var requestParams = getDifferentKeys(cacheKeyParams, cacheKeys);\n      return fetcher === null || fetcher === void 0 ? void 0 : fetcher(requestParams);\n    }, {\n      keepPreviousData: keepPreviousData\n    }),\n    swrData = _useSWR.data,\n    swrIsValidating = _useSWR.isValidating,\n    swrIsLoading = _useSWR.isLoading,\n    swrError = _useSWR.error,\n    swrMutate = _useSWR.mutate;\n  var _useSWRInfinite = useSWRInfinite(function (pageIndex) {\n      if (!triggerInfinite || !enabled) {\n        return null;\n      }\n      return _objectSpread(_objectSpread(_objectSpread({}, params), cacheKeys), {}, {\n        initialPage: initialPageRef.current + pageIndex,\n        pageSize: pageSizeRef.current\n      });\n    }, function (cacheKeyParams) {\n      var requestParams = getDifferentKeys(cacheKeyParams, cacheKeys);\n      return fetcher === null || fetcher === void 0 ? void 0 : fetcher(requestParams);\n    }),\n    swrInfiniteData = _useSWRInfinite.data,\n    swrInfiniteIsLoading = _useSWRInfinite.isLoading,\n    swrInfiniteIsValidating = _useSWRInfinite.isValidating,\n    swrInfiniteError = _useSWRInfinite.error,\n    size = _useSWRInfinite.size,\n    setSize = _useSWRInfinite.setSize,\n    swrInfiniteMutate = _useSWRInfinite.mutate;\n  var page = useMemo(function () {\n    if (triggerInfinite) {\n      return size;\n    }\n    return paginatedPage;\n  }, [triggerInfinite, size, paginatedPage]);\n  var fetchPage = useCallback(function (numberOrgFn) {\n    if (triggerInfinite) {\n      void setSize(numberOrgFn);\n      return;\n    }\n    return setPaginatedPage(numberOrgFn);\n  }, [setSize]);\n  var data = useMemo(function () {\n    var _swrData$data;\n    if (triggerInfinite) {\n      var _swrInfiniteData$map$;\n      return (_swrInfiniteData$map$ = swrInfiniteData === null || swrInfiniteData === void 0 ? void 0 : swrInfiniteData.map(function (a) {\n        return a === null || a === void 0 ? void 0 : a.data;\n      }).flat()) !== null && _swrInfiniteData$map$ !== void 0 ? _swrInfiniteData$map$ : [];\n    }\n    return (_swrData$data = swrData === null || swrData === void 0 ? void 0 : swrData.data) !== null && _swrData$data !== void 0 ? _swrData$data : [];\n  }, [triggerInfinite, swrData, swrInfiniteData]);\n  var count = useMemo(function () {\n    var _swrData$total_count;\n    if (triggerInfinite) {\n      var _swrInfiniteData;\n      return (swrInfiniteData === null || swrInfiniteData === void 0 || (_swrInfiniteData = swrInfiniteData[(swrInfiniteData === null || swrInfiniteData === void 0 ? void 0 : swrInfiniteData.length) - 1]) === null || _swrInfiniteData === void 0 ? void 0 : _swrInfiniteData.total_count) || 0;\n    }\n    return (_swrData$total_count = swrData === null || swrData === void 0 ? void 0 : swrData.total_count) !== null && _swrData$total_count !== void 0 ? _swrData$total_count : 0;\n  }, [triggerInfinite, swrData, swrInfiniteData]);\n  var isLoading = triggerInfinite ? swrInfiniteIsLoading : swrIsLoading;\n  var isFetching = triggerInfinite ? swrInfiniteIsValidating : swrIsValidating;\n  var isError = !!(triggerInfinite ? swrInfiniteError : swrError);\n  var fetchNext = useCallback(function () {\n    fetchPage(function (n) {\n      return Math.max(0, n + 1);\n    });\n  }, [fetchPage]);\n  var fetchPrevious = useCallback(function () {\n    fetchPage(function (n) {\n      return Math.max(0, n - 1);\n    });\n  }, [fetchPage]);\n  var offsetCount = (initialPageRef.current - 1) * pageSizeRef.current;\n  var pageCount = Math.ceil((count - offsetCount) / pageSizeRef.current);\n  var hasNextPage = count - offsetCount * pageSizeRef.current > page * pageSizeRef.current;\n  var hasPreviousPage = (page - 1) * pageSizeRef.current > offsetCount * pageSizeRef.current;\n  var unstable__mutate = triggerInfinite ? swrInfiniteMutate : swrMutate;\n  return {\n    data: data,\n    count: count,\n    isLoading: isLoading,\n    isFetching: isFetching,\n    isError: isError,\n    page: page,\n    pageCount: pageCount,\n    fetchPage: fetchPage,\n    fetchNext: fetchNext,\n    fetchPrevious: fetchPrevious,\n    hasNextPage: hasNextPage,\n    hasPreviousPage: hasPreviousPage,\n    unstable__mutate: unstable__mutate\n  };\n};\nexport { usePagesOrInfinite, useWithSafeValues };","map":{"version":3,"names":["useCallback","useMemo","useRef","useState","useSWR","useSWRInfinite","getDifferentKeys","obj1","obj2","keysSet","Set","Object","keys","differentKeysObject","_i","_Object$keys","length","key1","has","useWithSafeValues","params","defaultValues","_params$initialPage","_params$pageSize","shouldUseDefaults","initialPageRef","initialPage","pageSizeRef","pageSize","newObj","_i2","_Object$keys2","_params$key","key","_objectSpread","current","usePagesOrInfinite","fetcher","options","cacheKeys","_params$initialPage2","_params$initialPage3","_params$pageSize2","_options$enabled","_options$infinite","_options$keepPrevious","_useState","_useState2","_slicedToArray","paginatedPage","setPaginatedPage","enabled","triggerInfinite","infinite","keepPreviousData","pagesCacheKey","_useSWR","cacheKeyParams","requestParams","swrData","data","swrIsValidating","isValidating","swrIsLoading","isLoading","swrError","error","swrMutate","mutate","_useSWRInfinite","pageIndex","swrInfiniteData","swrInfiniteIsLoading","swrInfiniteIsValidating","swrInfiniteError","size","setSize","swrInfiniteMutate","page","fetchPage","numberOrgFn","_swrData$data","_swrInfiniteData$map$","map","a","flat","count","_swrData$total_count","_swrInfiniteData","total_count","isFetching","isError","fetchNext","n","Math","max","fetchPrevious","offsetCount","pageCount","ceil","hasNextPage","hasPreviousPage","unstable__mutate"],"sources":["/Users/hacktheplanet/Documents/GitHub/blog-frontend/node_modules/@clerk/shared/src/hooks/usePagesOrInfinite.ts"],"sourcesContent":["import { useCallback, useMemo, useRef, useState } from 'react';\nimport useSWR from 'swr';\nimport useSWRInfinite from 'swr/infinite';\n\nimport type { ValueOrSetter } from './types';\nimport type { PaginatedResources } from './types';\n\nfunction getDifferentKeys(obj1: Record<string, unknown>, obj2: Record<string, unknown>): Record<string, unknown> {\n  const keysSet = new Set(Object.keys(obj2));\n  const differentKeysObject: Record<string, unknown> = {};\n\n  for (const key1 of Object.keys(obj1)) {\n    if (!keysSet.has(key1)) {\n      differentKeysObject[key1] = obj1[key1];\n    }\n  }\n\n  return differentKeysObject;\n}\n\ntype PagesOrInfiniteOptions = {\n  /**\n   * This the starting point for your fetched results. The initial value persists between re-renders\n   */\n  initialPage?: number;\n  /**\n   * Maximum number of items returned per request. The initial value persists between re-renders\n   */\n  pageSize?: number;\n};\n\nexport const useWithSafeValues = <T extends PagesOrInfiniteOptions>(params: T | true | undefined, defaultValues: T) => {\n  const shouldUseDefaults = typeof params === 'boolean' && params;\n\n  // Cache initialPage and initialPageSize until unmount\n  const initialPageRef = useRef(\n    shouldUseDefaults ? defaultValues.initialPage : params?.initialPage ?? defaultValues.initialPage,\n  );\n  const pageSizeRef = useRef(shouldUseDefaults ? defaultValues.pageSize : params?.pageSize ?? defaultValues.pageSize);\n\n  const newObj: Record<string, unknown> = {};\n  for (const key of Object.keys(defaultValues)) {\n    // @ts-ignore\n    newObj[key] = shouldUseDefaults ? defaultValues[key] : params?.[key] ?? defaultValues[key];\n  }\n\n  return {\n    ...newObj,\n    initialPage: initialPageRef.current,\n    pageSize: pageSizeRef.current,\n  } as T;\n};\n\ntype ArrayType<DataArray> = DataArray extends Array<infer ElementType> ? ElementType : never;\ntype ExtractData<Type> = Type extends { data: infer Data } ? ArrayType<Data> : Type;\n\ntype UsePagesOrInfinite = <\n  Params extends PagesOrInfiniteOptions,\n  FetcherReturnData extends Record<string, any>,\n  CacheKeys = Record<string, unknown>,\n>(\n  /**\n   * The parameters will be passed to the fetcher\n   */\n  params: Params,\n  /**\n   * A Promise returning function to fetch your data\n   */\n  fetcher: ((p: Params) => FetcherReturnData | Promise<FetcherReturnData>) | undefined,\n  /**\n   * Internal configuration of the hook\n   */\n  options: {\n    /**\n     * Persists the previous pages with new ones in the same array\n     */\n    infinite?: boolean;\n    /**\n     * Return the previous key's data until the new data has been loaded\n     */\n    keepPreviousData?: boolean;\n    /**\n     * Should a request be triggered\n     */\n    enabled?: boolean;\n  },\n  cacheKeys: CacheKeys,\n) => PaginatedResources<ExtractData<FetcherReturnData>> & {\n  unstable__mutate: () => Promise<unknown>;\n};\n\nexport const usePagesOrInfinite: UsePagesOrInfinite = (params, fetcher, options, cacheKeys) => {\n  const [paginatedPage, setPaginatedPage] = useState(params.initialPage ?? 1);\n\n  // Cache initialPage and initialPageSize until unmount\n  const initialPageRef = useRef(params.initialPage ?? 1);\n  const pageSizeRef = useRef(params.pageSize ?? 10);\n\n  const enabled = options.enabled ?? true;\n  const triggerInfinite = options.infinite ?? false;\n  const keepPreviousData = options.keepPreviousData ?? false;\n\n  const pagesCacheKey = {\n    ...cacheKeys,\n    ...params,\n    initialPage: paginatedPage,\n    pageSize: pageSizeRef.current,\n  };\n\n  const {\n    data: swrData,\n    isValidating: swrIsValidating,\n    isLoading: swrIsLoading,\n    error: swrError,\n    mutate: swrMutate,\n  } = useSWR(\n    !triggerInfinite && !!fetcher && enabled ? pagesCacheKey : null,\n    cacheKeyParams => {\n      // @ts-ignore\n      const requestParams = getDifferentKeys(cacheKeyParams, cacheKeys);\n      // @ts-ignore\n      return fetcher?.(requestParams);\n    },\n    { keepPreviousData },\n  );\n\n  const {\n    data: swrInfiniteData,\n    isLoading: swrInfiniteIsLoading,\n    isValidating: swrInfiniteIsValidating,\n    error: swrInfiniteError,\n    size,\n    setSize,\n    mutate: swrInfiniteMutate,\n  } = useSWRInfinite(\n    pageIndex => {\n      if (!triggerInfinite || !enabled) {\n        return null;\n      }\n\n      return {\n        ...params,\n        ...cacheKeys,\n        initialPage: initialPageRef.current + pageIndex,\n        pageSize: pageSizeRef.current,\n      };\n    },\n    cacheKeyParams => {\n      // @ts-ignore\n      const requestParams = getDifferentKeys(cacheKeyParams, cacheKeys);\n      // @ts-ignore\n      return fetcher?.(requestParams);\n    },\n  );\n\n  const page = useMemo(() => {\n    if (triggerInfinite) {\n      return size;\n    }\n    return paginatedPage;\n  }, [triggerInfinite, size, paginatedPage]);\n\n  const fetchPage: ValueOrSetter<number> = useCallback(\n    numberOrgFn => {\n      if (triggerInfinite) {\n        void setSize(numberOrgFn);\n        return;\n      }\n      return setPaginatedPage(numberOrgFn);\n    },\n    [setSize],\n  );\n\n  const data = useMemo(() => {\n    if (triggerInfinite) {\n      return swrInfiniteData?.map(a => a?.data).flat() ?? [];\n    }\n    return swrData?.data ?? [];\n  }, [triggerInfinite, swrData, swrInfiniteData]);\n\n  const count = useMemo(() => {\n    if (triggerInfinite) {\n      return swrInfiniteData?.[swrInfiniteData?.length - 1]?.total_count || 0;\n    }\n    return swrData?.total_count ?? 0;\n  }, [triggerInfinite, swrData, swrInfiniteData]);\n\n  const isLoading = triggerInfinite ? swrInfiniteIsLoading : swrIsLoading;\n  const isFetching = triggerInfinite ? swrInfiniteIsValidating : swrIsValidating;\n  const isError = !!(triggerInfinite ? swrInfiniteError : swrError);\n  /**\n   * Helpers\n   */\n  const fetchNext = useCallback(() => {\n    fetchPage(n => Math.max(0, n + 1));\n  }, [fetchPage]);\n\n  const fetchPrevious = useCallback(() => {\n    fetchPage(n => Math.max(0, n - 1));\n  }, [fetchPage]);\n\n  const offsetCount = (initialPageRef.current - 1) * pageSizeRef.current;\n\n  const pageCount = Math.ceil((count - offsetCount) / pageSizeRef.current);\n  const hasNextPage = count - offsetCount * pageSizeRef.current > page * pageSizeRef.current;\n  const hasPreviousPage = (page - 1) * pageSizeRef.current > offsetCount * pageSizeRef.current;\n\n  const unstable__mutate = triggerInfinite ? swrInfiniteMutate : swrMutate;\n\n  return {\n    data,\n    count,\n    isLoading,\n    isFetching,\n    isError,\n    page,\n    pageCount,\n    fetchPage,\n    fetchNext,\n    fetchPrevious,\n    hasNextPage,\n    hasPreviousPage,\n    unstable__mutate,\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}