{"ast":null,"code":"import _slicedToArray from \"/Users/hacktheplanet/Documents/GitHub/blog-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { isHSLColor, isRGBColor, isTransparent, isValidHexString, isValidHslaString, isValidRgbaString } from \"./predicates\";\nvar CLEAN_HSLA_REGEX = /[hsla()]/g;\nvar CLEAN_RGBA_REGEX = /[rgba()]/g;\nvar stringToHslaColor = function stringToHslaColor(value) {\n  if (value === \"transparent\") {\n    return {\n      h: 0,\n      s: 0,\n      l: 0,\n      a: 0\n    };\n  }\n  if (isValidHexString(value)) {\n    return hexStringToHslaColor(value);\n  }\n  if (isValidHslaString(value)) {\n    return parseHslaString(value);\n  }\n  if (isValidRgbaString(value)) {\n    return rgbaStringToHslaColor(value);\n  }\n  return null;\n};\nvar stringToSameTypeColor = function stringToSameTypeColor(value) {\n  value = value.trim();\n  if (isValidHexString(value)) {\n    return value.startsWith(\"#\") ? value : \"#\".concat(value);\n  }\n  if (isValidRgbaString(value)) {\n    return parseRgbaString(value);\n  }\n  if (isValidHslaString(value)) {\n    return parseHslaString(value);\n  }\n  if (isTransparent(value)) {\n    return value;\n  }\n  return \"\";\n};\nvar colorToSameTypeString = function colorToSameTypeString(color) {\n  if (typeof color === \"string\" && (isValidHexString(color) || isTransparent(color))) {\n    return color;\n  }\n  if (isRGBColor(color)) {\n    return rgbaColorToRgbaString(color);\n  }\n  if (isHSLColor(color)) {\n    return hslaColorToHslaString(color);\n  }\n  return \"\";\n};\nvar hexStringToRgbaColor = function hexStringToRgbaColor(hex) {\n  hex = hex.replace(\"#\", \"\");\n  var r = parseInt(hex.substring(0, 2), 16);\n  var g = parseInt(hex.substring(2, 4), 16);\n  var b = parseInt(hex.substring(4, 6), 16);\n  return {\n    r: r,\n    g: g,\n    b: b\n  };\n};\nvar rgbaColorToRgbaString = function rgbaColorToRgbaString(color) {\n  var a = color.a,\n    b = color.b,\n    g = color.g,\n    r = color.r;\n  return color.a === 0 ? \"transparent\" : color.a != void 0 ? \"rgba(\".concat(r, \",\").concat(g, \",\").concat(b, \",\").concat(a, \")\") : \"rgb(\".concat(r, \",\").concat(g, \",\").concat(b, \")\");\n};\nvar hslaColorToHslaString = function hslaColorToHslaString(color) {\n  var h = color.h,\n    s = color.s,\n    l = color.l,\n    a = color.a;\n  var sPerc = Math.round(s * 100);\n  var lPerc = Math.round(l * 100);\n  return color.a === 0 ? \"transparent\" : color.a != void 0 ? \"hsla(\".concat(h, \",\").concat(sPerc, \"%,\").concat(lPerc, \"%,\").concat(a, \")\") : \"hsl(\".concat(h, \",\").concat(sPerc, \"%,\").concat(lPerc, \"%)\");\n};\nvar hexStringToHslaColor = function hexStringToHslaColor(hex) {\n  var rgbaString = colorToSameTypeString(hexStringToRgbaColor(hex));\n  return rgbaStringToHslaColor(rgbaString);\n};\nvar rgbaStringToHslaColor = function rgbaStringToHslaColor(rgba) {\n  var rgbaColor = parseRgbaString(rgba);\n  var r = rgbaColor.r / 255;\n  var g = rgbaColor.g / 255;\n  var b = rgbaColor.b / 255;\n  var max = Math.max(r, g, b),\n    min = Math.min(r, g, b);\n  var h, s;\n  var l = (max + min) / 2;\n  if (max == min) {\n    h = s = 0;\n  } else {\n    var d = max - min;\n    s = l >= 0.5 ? d / (2 - (max + min)) : d / (max + min);\n    switch (max) {\n      case r:\n        h = (g - b) / d * 60;\n        break;\n      case g:\n        h = ((b - r) / d + 2) * 60;\n        break;\n      default:\n        h = ((r - g) / d + 4) * 60;\n        break;\n    }\n  }\n  var res = {\n    h: Math.round(h),\n    s: s,\n    l: l\n  };\n  var a = rgbaColor.a;\n  if (a != void 0) {\n    res.a = a;\n  }\n  return res;\n};\nvar parseRgbaString = function parseRgbaString(str) {\n  var _str$replace$split$ma = str.replace(CLEAN_RGBA_REGEX, \"\").split(\",\").map(function (c) {\n      return Number.parseFloat(c);\n    }),\n    _str$replace$split$ma2 = _slicedToArray(_str$replace$split$ma, 4),\n    r = _str$replace$split$ma2[0],\n    g = _str$replace$split$ma2[1],\n    b = _str$replace$split$ma2[2],\n    a = _str$replace$split$ma2[3];\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n};\nvar parseHslaString = function parseHslaString(str) {\n  var _str$replace$split$ma3 = str.replace(CLEAN_HSLA_REGEX, \"\").split(\",\").map(function (c) {\n      return Number.parseFloat(c);\n    }),\n    _str$replace$split$ma4 = _slicedToArray(_str$replace$split$ma3, 4),\n    h = _str$replace$split$ma4[0],\n    s = _str$replace$split$ma4[1],\n    l = _str$replace$split$ma4[2],\n    a = _str$replace$split$ma4[3];\n  return {\n    h: h,\n    s: s / 100,\n    l: l / 100,\n    a: a\n  };\n};\nexport { colorToSameTypeString, hexStringToRgbaColor, stringToHslaColor, stringToSameTypeColor };","map":{"version":3,"names":["isHSLColor","isRGBColor","isTransparent","isValidHexString","isValidHslaString","isValidRgbaString","CLEAN_HSLA_REGEX","CLEAN_RGBA_REGEX","stringToHslaColor","value","h","s","l","a","hexStringToHslaColor","parseHslaString","rgbaStringToHslaColor","stringToSameTypeColor","trim","startsWith","concat","parseRgbaString","colorToSameTypeString","color","rgbaColorToRgbaString","hslaColorToHslaString","hexStringToRgbaColor","hex","replace","r","parseInt","substring","g","b","sPerc","Math","round","lPerc","rgbaString","rgba","rgbaColor","max","min","d","res","str","_str$replace$split$ma","split","map","c","Number","parseFloat","_str$replace$split$ma2","_slicedToArray","_str$replace$split$ma3","_str$replace$split$ma4"],"sources":["/Users/hacktheplanet/Documents/GitHub/blog-frontend/node_modules/@clerk/shared/src/utils/color/cssColorUtils.ts"],"sourcesContent":["import type { Color, HslaColor, RgbaColor, TransparentColor } from '@clerk/types';\n\nimport {\n  isHSLColor,\n  isRGBColor,\n  isTransparent,\n  isValidHexString,\n  isValidHslaString,\n  isValidRgbaString,\n} from './predicates';\n\nconst CLEAN_HSLA_REGEX = /[hsla()]/g;\nconst CLEAN_RGBA_REGEX = /[rgba()]/g;\n\nexport const stringToHslaColor = (value: string): HslaColor | null => {\n  if (value === 'transparent') {\n    return { h: 0, s: 0, l: 0, a: 0 };\n  }\n\n  if (isValidHexString(value)) {\n    return hexStringToHslaColor(value);\n  }\n\n  if (isValidHslaString(value)) {\n    return parseHslaString(value);\n  }\n\n  if (isValidRgbaString(value)) {\n    return rgbaStringToHslaColor(value);\n  }\n\n  return null;\n};\n\nexport const stringToSameTypeColor = (value: string): Color => {\n  value = value.trim();\n  if (isValidHexString(value)) {\n    return value.startsWith('#') ? value : `#${value}`;\n  }\n\n  if (isValidRgbaString(value)) {\n    return parseRgbaString(value);\n  }\n\n  if (isValidHslaString(value)) {\n    return parseHslaString(value);\n  }\n\n  if (isTransparent(value)) {\n    return value;\n  }\n  return '';\n};\n\nexport const colorToSameTypeString = (color: Color): string | TransparentColor => {\n  if (typeof color === 'string' && (isValidHexString(color) || isTransparent(color))) {\n    return color;\n  }\n\n  if (isRGBColor(color)) {\n    return rgbaColorToRgbaString(color);\n  }\n\n  if (isHSLColor(color)) {\n    return hslaColorToHslaString(color);\n  }\n\n  return '';\n};\n\nexport const hexStringToRgbaColor = (hex: string): RgbaColor => {\n  hex = hex.replace('#', '');\n  const r = parseInt(hex.substring(0, 2), 16);\n  const g = parseInt(hex.substring(2, 4), 16);\n  const b = parseInt(hex.substring(4, 6), 16);\n  return { r, g, b };\n};\n\nconst rgbaColorToRgbaString = (color: RgbaColor): string => {\n  const { a, b, g, r } = color;\n  return color.a === 0 ? 'transparent' : color.a != undefined ? `rgba(${r},${g},${b},${a})` : `rgb(${r},${g},${b})`;\n};\n\nconst hslaColorToHslaString = (color: HslaColor): string => {\n  const { h, s, l, a } = color;\n  const sPerc = Math.round(s * 100);\n  const lPerc = Math.round(l * 100);\n  return color.a === 0\n    ? 'transparent'\n    : color.a != undefined\n    ? `hsla(${h},${sPerc}%,${lPerc}%,${a})`\n    : `hsl(${h},${sPerc}%,${lPerc}%)`;\n};\n\nconst hexStringToHslaColor = (hex: string): HslaColor => {\n  const rgbaString = colorToSameTypeString(hexStringToRgbaColor(hex));\n  return rgbaStringToHslaColor(rgbaString);\n};\n\nconst rgbaStringToHslaColor = (rgba: string): HslaColor => {\n  const rgbaColor = parseRgbaString(rgba);\n  const r = rgbaColor.r / 255;\n  const g = rgbaColor.g / 255;\n  const b = rgbaColor.b / 255;\n\n  const max = Math.max(r, g, b),\n    min = Math.min(r, g, b);\n  let h, s;\n  const l = (max + min) / 2;\n\n  if (max == min) {\n    h = s = 0;\n  } else {\n    const d = max - min;\n    s = l >= 0.5 ? d / (2 - (max + min)) : d / (max + min);\n    switch (max) {\n      case r:\n        h = ((g - b) / d) * 60;\n        break;\n      case g:\n        h = ((b - r) / d + 2) * 60;\n        break;\n      default:\n        h = ((r - g) / d + 4) * 60;\n        break;\n    }\n  }\n\n  const res: HslaColor = { h: Math.round(h), s, l };\n  const a = rgbaColor.a;\n  if (a != undefined) {\n    res.a = a;\n  }\n  return res;\n};\n\nconst parseRgbaString = (str: string): RgbaColor => {\n  const [r, g, b, a] = str\n    .replace(CLEAN_RGBA_REGEX, '')\n    .split(',')\n    .map(c => Number.parseFloat(c));\n  return { r, g, b, a };\n};\n\nconst parseHslaString = (str: string): HslaColor => {\n  const [h, s, l, a] = str\n    .replace(CLEAN_HSLA_REGEX, '')\n    .split(',')\n    .map(c => Number.parseFloat(c));\n  return { h, s: s / 100, l: l / 100, a };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}